50 - 0101 0000
D0 - 1101 0000
F3
FA



FFFFCB7BC94C4BFC6D98CC318DE95F6F60C7E63FD71AAEF35C60A7FFFFFF



;22659=103433933306241977091027521327?

=======================================

22659=103433933306241977091027521327  iso2 트랙 데이터 값을 에러 없이 읽었을 때, decoder 에 대한 입려을 binary stream 으로 표현하면 아래와 같다
bit stream 의 앞뒤에 5비트의 1은 임의로 카드의 NULL 구간을 표시하기 위해 추가했고, 이상적인 상태에서 추가되는 1의 비트수는 더 늘어날 것이다.

foward : Inverted (LSB -> MSB), STX 의 LSB 부터 MSB 순서로 입력이 이루어 지고, 모든 비트는 반전된 값.
1111100101101111011110010010100110001001011111111000110110110011000110011000011000110001101111010010101111101101111011000001100011111100110001111111101011100011010101011101111001101011100011000001010011111


backward :  Byte-INV-Inverted (MSB -> LSB), LRC 의 MSB 부터 LSB 순서로 입력이 이루어 지고, 모든 비트는 반전된 값.
1111100101000001100011101011001111011101010101100011101011111111000110011111100011000001101111011011111010100101111011000110001100001100110001100110110110001111111101001000110010100100111101111011010011111

iso2 track 의 stx 는 P.D3.D2.D1.D0 = 01011 이므로 반전된 !stx 는 10100. 각 bit의 순서를 역으로 하면 io!stx 는 00101   (io 는 inversion order)
iso2 track 의 etx 는 P.D3.D2.D1.D0 = 11111 이므로 반전된 !etx 는 00000. 각 bit의 순서를 역으로 하면 io!etx 는 00000

backward 로 들어온 bitstream 을 forward 로 읽었다고 parsing 하면.
11111(NULL구간)  00101(io!stx)  00000(io!etx)  11000(io!lrc)  11101 011......
->  01011(stx), 11111(etx), 11100(found_lrc) 가 된다.
얻어진 lrc 의 pairy bit 정상임이 확인된다.
lrc 를 계산해보면, calulated_lrc = remove_parity_bit(stx xor etx) = remove_parity_bit(10100) = 0100
ISO7811 에 따라 parity 비트를 제외하고, 계산된 lrc(calulated_lrc) 와 얻은 lrc(found_lrc) 를 비교하면
calulated_lrc = 0100
found_lrc = 1100
기존 firmware 는 특수 사양 카드의 포맷을 지원하기 위해 calulated_lrc 와 found_lrc 이 다를 경우, MSB를 무시하므로
calulated_lrc = 1100
found_lrc = 1100
따라서 데이타 길이가 0 인 정상 카드로 인식된다.
======================================================================
65=464909107521327
iso2 트랙 데이터 값을 에러 없이 읽었을 때, decoder 에 대한 입려을 binary stream 으로 표현하면 아래와 같다
bit stream 의 앞뒤에 5비트의 1은 임의로 카드의 NULL 구간을 표시하기 위해 추가했고, 이상적인 상태에서 추가되는 1의 비트수는 더 늘어날 것이다.

foward : Inverted (LSB -> MSB), STX 의 LSB 부터 MSB 순서로 입력이 이루어 지고, 모든 비트는 반전된 값.
1111100101100100101001001110111001011011011001111001100011111111000011010101011101111001101011100011000001010011111

backward :  Byte-INV-Inverted (MSB -> LSB), LSB 의 MSB 부터 LSB 순서로 입력이 이루어 지고, 모든 비트는 반전된 값.
1111100101000001100011101011001111011101010101100001111111100011001111001101101101001110111001001010010011010011111

iso2 track 의 stx 는 P.D3.D2.D1.D0 = 01011 이므로 반전된 !stx 는 10100. 각 bit의 순서를 역으로 하면 io!stx 는 00101   (io 는 inversion order)
iso2 track 의 etx 는 P.D3.D2.D1.D0 = 11111 이므로 반전된 !etx 는 00000. 각 bit의 순서를 역으로 하면 io!etx 는 00000

backward 로 들어온 bitstream 을 forward 로 읽었다고 parsing 하면.
11111(NULL구간)  00101(io!stx)  00000(io!etx)  11000(io!lrc)  11101 011......
->  01011(stx), 11111(etx), 11100(found_lrc) 가 된다.
얻어진 lrc 의 pairy bit 정상임이 확인된다.

lrc 를 계산해보면, calulated_lrc = remove_parity_bit(stx xor etx) = remove_parity_bit(10100) = 0100
ISO7811 에 따라 parity 비트를 제외하고, 계산된 lrc(calulated_lrc) 와 얻은 lrc(found_lrc) 를 비교하면
calulated_lrc = 0100
found_lrc = 1100
기존 firmware 는 특수 사양 카드의 포맷을 지원하기 위해 calulated_lrc 와 found_lrc 이 다를 경우, MSB를 무시하므로
calulated_lrc = 1100
found_lrc = 1100
따라서 데이타 길이가 0 인 정상 카드로 인식된다.
============================
Inverted (LSB -> MSB):
0010111110111011101110111111100000010100

11111001011111011101110111011111110000001010011111

Byte-INV-Inverted (MSB -> LSB):
0010100000011111110111011101110111110100


22659=120683856706841996072046530564

Byte-INV-Inverted (MSB -> LSB):
Encoded data: 001010000011011010010101001111011000101001001110110111111101110000111101001001100011011110110111011101001011111100001001010101011101100101110100101111111011111010010001100101001001111011110110100

backward 로 읽은 데이터를 forward 로 분석하면.
00101.00000.11011.010010101001111011000101001001110110111111101110000111101001001100011011110110111011101001011111100001001010101011101100101110100101111111011111010010001100101001001111011110110100

io!stx=00101 -> stx=01011
io!etx=00000 -> etx=11111
id!lrc=11011 -> lrc=00100
